#!/usr/bin/python
import re, sys, os
import clang.cindex
import Queue

from report import Report
from helpers import LIB_CLANG_PATH, getExtension

#This will match (and not capture) any local or member variable in camel case
VAR = ur'([a-z][a-z0-9]*(?:[A-Z][a-z0-9]*)*_?)'

#This is the error message for all "this" relates style/idiom issues
THIS_ERR = "Member variables and functions can be called as foo_ and bar().\nRefrain from using (*this).foo_ or this->bar().\n"

#This will match anything of the form (*VAR).VAR
derefDotRegex = "\( *\* *" + VAR +" *\)." + VAR
derefDot = re.compile(derefDotRegex)

#This matches the this->VAR case which is idiomaticlly bad
thisArrowRegex = "this->" + VAR
thisArrow = re.compile(thisArrowRegex)

#This checks for using namespaces
usingRegex = ur"using namespace .*;"
using = re.compile(usingRegex)

#Because we dont get find the errors in order we store them in a queue and print
#them later
outQueue = Queue.PriorityQueue()

def checkCStyleCast(fileName, report):
  clang.cindex.Config.set_library_file(LIB_CLANG_PATH)
  index = clang.cindex.Index.create()
  tu = index.parse(fileName)
  cCastCheckHelper(tu.cursor, report)

def cCastCheckHelper(node, report):
  '''Using libclang to check for C-Style casts'''
  if node.kind == clang.cindex.CursorKind.CSTYLE_CAST_EXPR:
    errString = IDIOM + " line: " + str(node.location.line) + " col: " + str(node.location.column) + "\n"
    errString += "Using a C-Style cast is non-idiomatic.\n"
    outQueue.put((node.location.line, node.location.column, errString))

  for c in node.get_children():
    cCastCheck(c)

def idiomCheck(fileName):
  '''This function tests for CS70 idiomatic issues'''
  #Regex based idiom checks here
  with open(fileName, 'r') as f:
    #Go through each line so we can report postions
    for lineNum, line in enumerate(f):
      m = derefDot.search(line)
      if m != None:
        errString = IDIOM + " line: " + str(lineNum+1) + " col: " + str(m.start()) + "\n"
        #If the first variable is "this" we print a different error
        if m.group(1) == "this":
          errString += THIS_ERR
        else:
          errString += "Avoid using (*foo).bar instead use foo->bar\n"
        outQueue.put((lineNum+1, m.start(), errString))

      m = thisArrow.search(line)
      if m != None:
        errString = IDIOM + " line: " + str(lineNum+1) + " col: " + str(m.start()) + "\n"
        errString += THIS_ERR
        outQueue.put((lineNum+1, m.start(), errString))

  #We leverage libclang at this point to check for C-Style casts
  index = clang.cindex.Index.create()
  tu = index.parse(fileName)
  cCastCheck(tu.cursor)
  return

def unsafeCheck(fileName):
  '''This checks for CS70 unsafe practices'''
  if getExtension(fileName) in ['.hpp','.h','.hh']:
    #If it is a header file make sure that it doesn't have using directives
    with open(fileName, 'r') as f:
      for lineNum, line in enumerate(f):
        m = using.search(line)
        if m != None:
          errString = UNSAFE + " line: " + str(lineNum+1) + " col: " + str(m.start()) + "\n"
          errString += "using directives should not appear in header files\n"
          outQueue.put((lineNum+1, m.start(), errString))
  pass

if __name__ == "__main__":
  clang.cindex.Config.set_library_file('/usr/lib/llvm-3.3/lib/libclang.so')
  for fileName in sys.argv[1:]:
    outQueue = Queue.PriorityQueue()
    print "="*80
    print "Checking: " + fileName + '\n'
    idiomCheck(fileName)
    unsafeCheck(fileName)
    while not outQueue.empty():
      out = outQueue.get()
      print out[2]
